# Generated by Django 4.2.8

from django.db import migrations


def migrate_items_to_exportitem(apps, schema_editor):
    """
    Migrate data from GM2M items field to new ExportItem model.
    
    Uses raw SQL for maximum performance when moving data from the GM2M through table
    (outputs_export_items) to the new ExportItem table. This is much faster than
    iterating through Python objects, especially for large datasets.
    
    The GM2M through table structure:
    - gm2m_src_id: the Export id
    - gm2m_ct_id: the ContentType id
    - gm2m_pk: the object id (primary key of the target object, stored as VARCHAR)
    """
    with schema_editor.connection.cursor() as cursor:
        # Count rows before migration
        cursor.execute("SELECT COUNT(*) FROM outputs_export_items")
        source_count = cursor.fetchone()[0]
        print(f"Found {source_count} rows in outputs_export_items table")

        if source_count == 0:
            print("WARNING: No data to migrate - GM2M table is empty")
            return

        # Use INSERT ... SELECT for efficient bulk data transfer
        # This directly copies data from the GM2M through table to ExportItem
        # created/modified come from the related Export's created (modified has no DB default)
        # Filter to only numeric PKs to avoid casting errors
        cursor.execute("""
            INSERT INTO outputs_exportitem (
                export_id,
                content_type_id,
                object_id,
                result,
                detail,
                created,
                modified
            )
            SELECT DISTINCT
                ei.gm2m_src_id,
                ei.gm2m_ct_id,
                ei.gm2m_pk::integer,
                'SUCCESS',
                '',
                e.created,
                e.created
            FROM outputs_export_items ei
            INNER JOIN outputs_export e ON ei.gm2m_src_id = e.id
            WHERE ei.gm2m_pk ~ '^[0-9]+$'
        """)
        
        # Capture rowcount immediately after INSERT, before any other queries
        # (SELECT queries will overwrite cursor.rowcount)
        inserted_count = cursor.rowcount
        print(f"Successfully inserted {inserted_count} rows into outputs_exportitem")
        
        # Count any skipped rows (non-numeric PKs)
        cursor.execute("""
            SELECT COUNT(*) 
            FROM outputs_export_items ei
            WHERE ei.gm2m_pk !~ '^[0-9]+$'
        """)


def reverse_migration(apps, schema_editor):
    """
    Reverse migration: copy data back from ExportItem to GM2M table.

    This restores the data from ExportItem back to the GM2M through table
    (outputs_export_items) before deleting ExportItem objects.
    """
    ExportItem = apps.get_model('outputs', 'ExportItem')

    with schema_editor.connection.cursor() as cursor:
        # Check if the GM2M table exists
        cursor.execute("""
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND table_name = 'outputs_export_items'
            );
        """)
        table_exists = cursor.fetchone()[0]

        if not table_exists:
            print("WARNING: outputs_export_items table does not exist!")
            print("Cannot restore GM2M data - table was likely dropped by migration 0022")
            print("Deleting ExportItem objects anyway...")
            ExportItem.objects.all().delete()
            return

        # Count ExportItem rows to restore
        export_item_count = ExportItem.objects.count()
        print(f"Found {export_item_count} ExportItem rows to restore")

        if export_item_count == 0:
            print("No ExportItem data to restore")
            return

        # Restore data from ExportItem back to GM2M through table
        # Note: gm2m_pk needs to be cast to VARCHAR to match the GM2M table structure
        # We only insert the columns we know exist: gm2m_src_id, gm2m_ct_id, gm2m_pk
        # Using DISTINCT because GM2M table has unique constraint on (gm2m_src_id, gm2m_ct_id, gm2m_pk)
        cursor.execute("""
            INSERT INTO outputs_export_items (
                gm2m_src_id,
                gm2m_ct_id,
                gm2m_pk
            )
            SELECT DISTINCT
                ei.export_id,
                ei.content_type_id,
                ei.object_id::varchar
            FROM outputs_exportitem ei
            ON CONFLICT DO NOTHING
        """)

        print(f"Successfully restored {export_item_count} rows to GM2M table")
        
        # Now delete ExportItem objects
        ExportItem.objects.all().delete()
        print("Deleted ExportItem objects")


class Migration(migrations.Migration):

    dependencies = [
        ('outputs', '0020_exportitem'),
    ]

    operations = [
        migrations.RunPython(migrate_items_to_exportitem, reverse_migration),
    ]

